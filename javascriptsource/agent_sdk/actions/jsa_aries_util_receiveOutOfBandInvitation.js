// This file was generated by Mendix Studio Pro.
//
// WARNING: Only the following code will be retained when actions are regenerated:
// - the import list
// - the code between BEGIN USER CODE and END USER CODE
// - the code between BEGIN EXTRA CODE and END EXTRA CODE
// Other code you write will be lost the next time you deploy the project.
import "mx-global";
import { Big } from "big.js";

// BEGIN EXTRA CODE
import "../shim.js";
import support from"../support/entidad";
//import{parseMessageType,V2OfferCredentialMessage,V2RequestPresentationMessage,CredentialEventTypes,CredentialState,ProofEventTypes,ProofState,OutOfBandRepository}from"@aries-framework/core";
//import {V1OfferCredentialMessage,V1RequestPresentationMessage} from '@aries-framework/anoncreds'
//import { supportsIncomingMessageType } from '@aries-framework/core/build/utils/messageType'
import{filter,firstValueFrom,merge,first,timeout}from"rxjs";
// END EXTRA CODE

/**
 * @param {string} agent_key
 * @param {string} invitationUrl - string
 * @returns {Promise.<string>}
 */
export async function jsa_aries_util_receiveOutOfBandInvitation(agent_key, invitationUrl) {
	// BEGIN USER CODE
	try{
		if(agent_key==null)return Promise.reject("Invalid agent_key parameter");
		let agent=support.cache.get(agent_key);
		if(agent==null)return Promise.reject("Agent not found in cache");
		if(invitationUrl==null||invitationUrl.length==0)return Promise.reject("Invalid invitationUrl parameter");
		//let res=await agent.oob.findByReceivedInvitationId(receivedInvitationId);
		let invitation=await agent.oob.parseInvitation(invitationUrl)		
		//------------------------------------------------------------------
		const requestMessages=invitation.getRequests()??[];
		if(requestMessages.length>1){
			const message='Message contains multiple requests. Invitation should only contain a single request.';
			agent.config.logger.error(message);
			return Promise.reject({
				id:0,
				result:'error',
				message,
			});
		}
		// In this case we probably need to create a connection first. We will do this here, as we don't allow to just
		// create a connection
		if(requestMessages.length===0){
			if(!invitation.handshakeProtocols||invitation.handshakeProtocols.length===0){
				agent.config.logger.error('No requests and no handshake protocols found in invitation.')
				return{
					id:1,
					result:'error',
					message:'Invalid invitation.',
				}
			}
		}else{
		// Validate the type of the request message
			const requestMessage=requestMessages[0]/* as PlaintextMessage*/;
			const parsedMessageType=parseMessageType(requestMessage['@type']);
			const isValidRequestMessage=
				supportsIncomingMessageType(parsedMessageType,V1OfferCredentialMessage.type)||
				supportsIncomingMessageType(parsedMessageType,V2OfferCredentialMessage.type)||
				supportsIncomingMessageType(parsedMessageType,V1RequestPresentationMessage.type)||
				supportsIncomingMessageType(parsedMessageType,V2RequestPresentationMessage.type)
			;
			if(!isValidRequestMessage){
				agent.config.logger.error('Message request is not from supported protocol.')
				Promise.reject(JSON.stringify({
					id:2,
					result:'error',
					message:'Invalid invitation.',
				}));
			}
		}
		// The value is reassigned, but eslint doesn't know this.
		// eslint-disable-next-line prefer-const
		let connectionId/*: string | undefined*/;
		const credentialOffer=agent.events
			.observable/*<CredentialStateChangedEvent>*/(CredentialEventTypes.CredentialStateChanged)
			.pipe(
				filter((event)=>event.payload.credentialRecord.state===CredentialState.OfferReceived),
				filter((event)=>event.payload.credentialRecord.connectionId===connectionId)
			)
		;
		const proofRequest=agent.events
			.observable/*<ProofStateChangedEvent>*/(ProofEventTypes.ProofStateChanged)
			.pipe(
				filter((event)=>event.payload.proofRecord.state===ProofState.RequestReceived),
				filter((event)=>event.payload.proofRecord.connectionId===connectionId)
			)
		;
		const eventPromise=firstValueFrom(
			merge(credentialOffer,proofRequest).pipe(
				first(),
				// We allow 15 seconds to receive a credential offer or proof request
				timeout(15*1000)
			)
		);
		let connectionRecord/*: ConnectionRecord | undefined*/;
		let outOfBandRecord/*: OutOfBandRecord*/;
		try{
			// Check if invitation already exists
			const receivedInvite=await agent.oob.findByReceivedInvitationId(invitation.id);
			if(receivedInvite){
				return Promise.reject(JSON.stringify({
					id:3,
					result:'error',
					message:'Invitation has already been scanned.',
				}));
			}
			const receiveInvitationResult=await agent.oob.receiveInvitation(invitation,{
				reuseConnection:true,
			});
			connectionRecord=receiveInvitationResult.connectionRecord;
			outOfBandRecord=receiveInvitationResult.outOfBandRecord;
			// Assign connectionId so it can be used in the observables.
			connectionId=connectionRecord?.id;
		}catch(error){
			agent.config.logger.error(`Error while receiving invitation: ${error.toString()}`);
			return Promise.reject(JSON.stringify({
				id:4,
				result:'error',
				message:'Invalid invitation.',
			}));
		}
		try{
			const event=await eventPromise;
			agent.config.logger.debug(`Received event ${event.type}`);
			if(event.type===CredentialEventTypes.CredentialStateChanged){
				return Promise.resolve(JSON.stringify({
					id:5,
					result:'success',
					credentialExchangeId:event.payload.credentialRecord.id,
				}));
			}else if(event.type===ProofEventTypes.ProofStateChanged){
				return Promise.resolve(JSON.stringify({
					id:6,
					result:'success',
					proofExchangeId:event.payload.proofRecord.id,
				}));
			}
		}catch(error){
			agent.config.logger.error(`Error while waiting for credential offer or proof request. Deleting connection and records`);
			// Delete OOB record
			const outOfBandRepository=agent.dependencyManager.resolve(OutOfBandRepository);
			await outOfBandRepository.deleteById(agent.context,outOfBandRecord.id);
			// Delete connection record
			// TODO: delete did and mediation stuff
			if(connectionRecord){
				await agent.connections.deleteById(connectionRecord.id);
			}
			return Promise.reject(JSON.stringify({
				id:7,
				result:'error',
				message:'Invalid invitation.'
			}));
		}
		return Promise.reject(JSON.stringify({
			id:8,
			result:'error',
			message:'Invalid invitation.'
		}));
	}catch(e){
		return Promise.reject(JSON.stringify({
			id:9,
			result:'error',
			message:e.toString()
		}));
	}
	// END USER CODE
}
